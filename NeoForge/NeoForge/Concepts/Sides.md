# Стороны

Как и многие другие программы, Minecraft следует концепции клиент-сервер, где клиент отвечает за отображение данных, а сервер — за их обновление. Используя эти термины, у нас есть довольно интуитивное понимание того, что мы имеем в виду... верно?

Оказывается, не совсем. Большая часть путаницы возникает из-за того, что в Minecraft существует два разных понятия сторон, в зависимости от контекста: физическая и логическая сторона.

<a id="logical-vs-physical-side"></a>

## Логическая и Физическая Сторона

<a id="the-physical-side"></a>

### Физическая Сторона

Когда вы открываете лаунчер Minecraft, выбираете установленную версию Minecraft и нажимаете "Играть", вы запускаете физический клиент. Слово "физический" здесь используется в смысле "это клиентская программа". Именно на физическом клиенте доступна и может быть использована вся функциональность, отвечающая за отображение (рендеринг) и другие клиентские задачи. В противоположность этому, физический сервер, также известный как выделенный сервер, — это то, что открывается при запуске JAR-файла сервера Minecraft. Хотя сервер Minecraft поставляется с рудиментарным графическим интерфейсом, в нем отсутствует вся функциональность, присущая только клиенту. Самое главное, это означает, что различные классы клиента отсутствуют в JAR-файле сервера. Вызов этих классов на физическом сервере приведет к ошибкам отсутствия классов, то есть к сбоям, поэтому нам нужно защищаться от этого.

<a id="the-logical-side"></a>

### Логическая Сторона

Логическая сторона в основном сосредоточена на внутренней структуре программы Minecraft. **Логический сервер** — это место, где выполняется игровая логика. Такие вещи, как смена времени суток и погоды, обработка тиков сущностей, спавн сущностей и т. д., выполняются на сервере. Все виды данных, такие как содержимое инвентаря, также являются зоной ответственности сервера. **Логический клиент**, с другой стороны, отвечает за отображение всего, что нужно отобразить. Minecraft хранит весь клиентский код в изолированном пакете `net.minecraft.client` и выполняет его в отдельном потоке, называемом Render Thread (Поток Рендеринга), в то время как все остальное считается общим кодом (т. е. кодом клиента и сервера).

<a id="whats-the-difference"></a>

### В чем разница?

Разница между физической и логической сторонами лучше всего иллюстрируется двумя сценариями:

*   Игрок присоединяется к **многопользовательскому** миру. Это довольно просто: физический (и логический) клиент игрока подключается к физическому (и логическому) серверу где-то еще — игроку не важно, где; пока он может подключиться, это все, что клиент знает, и все, что ему нужно знать.
*   Игрок присоединяется к **однопользовательскому** миру. Вот здесь все становится интересно. Физический клиент игрока запускает логический сервер, а затем, уже в роли логического клиента, подключается к этому логическому серверу на той же машине. Если вы знакомы с сетевыми технологиями, вы можете представить это как подключение к `localhost` (только концептуально; реальные сокеты или подобные вещи не используются).

Эти два сценария также показывают основную проблему: если логический сервер может работать с вашим кодом, это само по себе не гарантирует, что физический сервер сможет работать с ним так же хорошо. Вот почему вы всегда должны тестировать на выделенных серверах, чтобы проверить наличие неожиданного поведения. Ошибки `NoClassDefFoundError` и `ClassNotFoundException` из-за неправильного разделения клиента и сервера являются одними из самых распространенных ошибок в моддинге. Еще одна распространенная ошибка — работа со статическими полями и доступ к ним с обеих логических сторон; это особенно сложно, потому что обычно нет никаких признаков того, что что-то не так.

> **Совет:**
> Если вам нужно передать данные с одной стороны на другую, вы должны [отправить пакет](../networking/index.md).

В кодовой базе NeoForge физическая сторона представлена перечислением `Dist`, а логическая сторона — перечислением `LogicalSide`.

> **Информация:**
> Исторически серверные JAR-файлы содержали классы, которых не было у клиента. В современных версиях это уже не так; физические серверы являются, так сказать, подмножеством физических клиентов.

<a id="performing-side-specific-operations"></a>

## Выполнение операций, специфичных для стороны

<a id="levelisclientside"></a>

### `Level#isClientSide()`

Эта логическая проверка будет вашим наиболее часто используемым способом проверки сторон. Запрос этого поля у объекта `Level` устанавливает **логическую** сторону, к которой принадлежит уровень: если это поле равно `true`, уровень выполняется на логическом клиенте. Если поле равно `false`, уровень выполняется на логическом сервере. Отсюда следует, что физический сервер всегда будет содержать `false` в этом поле, но мы не можем предполагать, что `false` подразумевает физический сервер, так как это поле также может быть `false` для логического сервера внутри физического клиента (т. е. в однопользовательском мире).

Используйте эту проверку всякий раз, когда вам нужно определить, должна ли выполняться игровая логика и другие механики. Например, если вы хотите наносить урон игроку каждый раз, когда он нажимает на ваш блок, или заставить вашу машину перерабатывать землю в алмазы, вы должны делать это только после того, как убедитесь, что `#isClientSide` равно `false`. Применение игровой логики к логическому клиенту может вызвать рассинхронизацию (фантомные сущности, рассинхронизированные характеристики и т. д.) в лучшем случае и сбои в худшем.

> **Совет:**
> Эту проверку следует использовать по умолчанию. Всякий раз, когда у вас есть доступ к `Level`, используйте эту проверку.

<a id="fmlenvironmentdist"></a>

### `FMLEnvironment.dist`

`FMLEnvironment.dist` — это **физический** аналог проверки `Level#isClientSide()`. Если это поле равно `Dist.CLIENT`, вы находитесь на физическом клиенте. Если поле равно `Dist.DEDICATED_SERVER`, вы находитесь на физическом сервере.

<a id="mod"></a>

#### `@Mod`

Проверка физической среды важна при работе с классами, существующими только на клиенте. Рекомендуемый способ разделения кода, который должен выполняться только на одном физическом клиенте, — это указание отдельной [аннотации `@Mod`](../Getting%20Started/Mod%20Files.md#javafml-and-mod), установив параметр `dist` на физическую сторону, на которой должен быть загружен класс мода:

```java
@Mod("examplemod")
public class ExampleMod {
    public ExampleMod(IEventBus modBus) {
        // Выполнение логики, которая должна выполняться на обеих сторонах
    }
}

@Mod(value = "examplemod", dist = Dist.CLIENT)
public class ExampleModClient {
    public ExampleModClient(IEventBus modBus) {
        // Выполнение логики, которая должна выполняться только на физическом клиенте
        Minecraft.getInstance().whatever();
    }
}

@Mod(value = "examplemod", dist = Dist.DEDICATED_SERVER)
public class ExampleModDedicatedServer {
    public ExampleModDedicatedServer(IEventBus modBus) {
        // Выполнение логики, которая должна выполняться только на физическом сервере
    }
}

```

> **Совет:**
> Обычно ожидается, что моды будут работать на любой стороне. Поэтому, если вы разрабатываете мод только для клиента, вы должны убедиться, что он корректно функционирует на физическом клиенте и не вызывает ошибок (или бездействует) при попытке запуска на физическом сервере.

---
<div align="center"><table><tr><td align="center">Предыдущий раздел<br><a href="./Registries.md">Реестры</a></td><td align="center">Следующий раздел<br><a href="../networking/index.md">Сеть</a></td></tr></table></div>

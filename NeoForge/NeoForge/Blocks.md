# Блоки

Блоки — неотъемлемая часть мира Minecraft. Из них состоит вся местность, структуры и механизмы. Скорее всего, если вы заинтересованы в создании мода, вы захотите добавить свои блоки. Эта страница поможет вам в создании блоков и расскажет о некоторых вещах, которые вы можете с ними делать.

## Один блок, чтобы править всеми

Прежде чем мы начнем, важно понимать, что в игре существует только по одному экземпляру каждого блока. Мир состоит из тысяч ссылок на этот один блок в разных местах. Другими словами, один и тот же блок просто отображается много раз.

Из-за этого блок должен создаваться только один раз, и это происходит во время [регистрации](./Concepts/Registries.md#способы-регистрации). Как только блок зарегистрирован, вы можете использовать зарегистрированную ссылку по мере необходимости.

В отличие от большинства других реестров, блоки могут использовать специализированную версию `DeferredRegister`, называемую `DeferredRegister.Blocks`. `DeferredRegister.Blocks` действует в основном как `DeferredRegister<Block>`, но с некоторыми незначительными отличиями:

*   Они создаются с помощью `DeferredRegister.createBlocks("yourmodid")` вместо обычного метода `DeferredRegister.create(...)`.
*   `#register` возвращает `DeferredBlock<T extends Block>`, который расширяет `DeferredHolder<Block, T>`. `T` — это тип класса блока, который мы регистрируем.
*   Существует несколько вспомогательных методов для регистрации блоков. См. [ниже](#вспомогательные-методы-deferredregisterblocks) для получения дополнительной информации.

Итак, давайте зарегистрируем наши блоки:

```java
// BLOCKS - это DeferredRegister.Blocks
public static final DeferredBlock<Block> MY_BLOCK = BLOCKS.register("my_block", registryName -> new Block(...));
```

После регистрации блока все ссылки на новый `my_block` должны использовать эту константу. Например, если вы хотите проверить, является ли блок в заданной позиции `my_block`, код для этого будет выглядеть примерно так:

```java
level.getBlockState(position) // возвращает состояние блока, размещенного в данном уровне (мире) в данной позиции
    .is(MyBlockRegistrationClass.MY_BLOCK);
```

Этот подход также имеет удобный эффект: `block1 == block2` работает и может использоваться вместо метода `equals` Java (использование `equals` все еще работает, конечно, но бессмысленно, так как он все равно сравнивает по ссылке).

> **Опасно:**
> Не вызывайте `new Block()` вне регистрации! Как только вы это сделаете, все может сломаться и сломается:
>
> *   Блоки должны создаваться, пока реестры разморожены. NeoForge размораживает реестры для вас и замораживает их позже, поэтому регистрация — это ваше временное окно для создания блоков.
> *   Если вы попытаетесь создать и/или зарегистрировать блок, когда реестры снова заморожены, игра вылетит и сообщит о `null` блоке, что может быть очень запутанным.
> *   Если вам все же удастся получить "висящий" экземпляр блока, игра не распознает его при синхронизации и сохранении и заменит его воздухом.

## Создание блоков

Как обсуждалось ранее, мы начинаем с создания нашего `DeferredRegister.Blocks`:

```java
public static final DeferredRegister.Blocks BLOCKS = DeferredRegister.createBlocks("yourmodid");
```

### Базовые блоки

Для простых блоков, не требующих особой функциональности (например, булыжник, деревянные доски и т. д.), можно использовать непосредственно класс `Block`. Для этого при регистрации создайте экземпляр `Block` с параметром `BlockBehaviour.Properties`. Этот параметр `BlockBehaviour.Properties` можно создать с помощью `BlockBehaviour.Properties#of`, и его можно настроить, вызывая его методы. Наиболее важные методы для этого:

*   `setId` - Устанавливает ключ ресурса блока.
    *   Это **должно** быть установлено для каждого блока, иначе возникнет исключение.
*   `destroyTime` - Определяет время, необходимое для разрушения блока.
    *   У камня время разрушения 1.5, у земли 0.5, у обсидиана 50, а у бедрока -1 (неразрушимый).
*   `explosionResistance` - Определяет сопротивление блока взрывам.
    *   У камня сопротивление взрыву 6.0, у земли 0.5, у обсидиана 1,200, а у бедрока 3,600,000.
*   `sound` - Устанавливает звук, который издает блок при ударе, разрушении или размещении.
    *   Значение по умолчанию — `SoundType.STONE`. См. страницу [Звуки](../../resources/client/sounds.md) для получения дополнительной информации.
*   `lightLevel` - Устанавливает уровень излучаемого света блока. Принимает функцию с параметром `BlockState`, которая возвращает значение от 0 до 15.
    *   Например, светокамень использует `state -> 15`, а факелы — `state -> 14`.
*   `friction` - Устанавливает трение (скользкость) блока.
    *   Значение по умолчанию — 0.6. Лед использует 0.98.

Например, простая реализация будет выглядеть примерно так:

```java
// BLOCKS - это DeferredRegister.Blocks
public static final DeferredBlock<Block> MY_BETTER_BLOCK = BLOCKS.register(
    "my_better_block",
    registryName -> new Block(BlockBehaviour.Properties.of()
        .setId(ResourceKey.create(Registries.BLOCK, registryName))
        .destroyTime(2.0f)
        .explosionResistance(10.0f)
        .sound(SoundType.GRAVEL)
        .lightLevel(state -> 7)
    )
);
```

Для получения дополнительной документации см. исходный код `BlockBehaviour.Properties`. Для большего количества примеров или для просмотра значений, используемых Minecraft, загляните в класс `Blocks`.

> **Примечание:**
> Важно понимать, что блок в мире — это не то же самое, что блок в инвентаре. То, что выглядит как блок в инвентаре, на самом деле является `BlockItem`, особым типом [предмета](../../items/index.md), который размещает блок при использовании. Это также означает, что такие вещи, как вкладка творческого режима или максимальный размер стопки, обрабатываются соответствующим `BlockItem`.
>
> `BlockItem` должен быть зарегистрирован отдельно от блока. Это связано с тем, что блоку не обязательно нужен предмет, например, если он не предназначен для сбора (как в случае с огнем).

### Дополнительная функциональность

Прямое использование `Block` позволяет создавать только самые базовые блоки. Если вы хотите добавить функциональность, такую как взаимодействие с игроком или другую область столкновения (hitbox), требуется пользовательский класс, расширяющий `Block`. Класс `Block` имеет множество методов, которые можно переопределить для выполнения различных действий; см. классы `Block`, `BlockBehaviour` и `IBlockExtension` для получения дополнительной информации. См. также раздел [Использование блоков](#использование-блоков) ниже для некоторых из наиболее распространенных вариантов использования блоков.

Если вы хотите создать блок с различными вариантами (например, плита с вариантами "низ", "верх" и "двойная"), вам следует использовать [состояния блоков](states.md). И, наконец, если вам нужен блок, который хранит дополнительные данные (например, сундук, хранящий свой инвентарь), следует использовать [сущность блока (block entity)](../blockentities/index.md). Эмпирическое правило здесь таково: если у вас конечное и достаточно небольшое количество состояний (= несколько сотен состояний максимум), используйте состояния блоков, а если у вас бесконечное или почти бесконечное количество состояний, используйте сущность блока.

#### Типы блоков

Типы блоков — это [`MapCodec`](../../datastorage/codecs.md#записи), используемые для сериализации и десериализации объекта блока. Этот `MapCodec` устанавливается через `BlockBehaviour#codec` и [регистрируется](./Concepts/Registries.md#способы-регистрации) в реестре типов блоков. В настоящее время его единственное применение — генерация отчета списка блоков. Тип блока должен создаваться один раз для каждого подкласса `Block`. Например, `FlowerBlock#CODEC` представляет тип блока для большинства цветов, в то время как его подкласс `WitherRoseBlock` имеет отдельный тип блока.

Если подкласс блока принимает только `BlockBehaviour.Properties`, то для создания `MapCodec` можно использовать `BlockBehaviour#simpleCodec`.

```java
// Для некоторого подкласса блока
public class SimpleBlock extends Block {
    public SimpleBlock(BlockBehavior.Properties properties) {
        // ...
    }

    @Override
    public MapCodec<SimpleBlock> codec() {
        return SIMPLE_CODEC.get();
    }
}

// В некотором классе регистрации
public static final DeferredRegister<MapCodec<? extends Block>> REGISTRAR = DeferredRegister.create(BuiltInRegistries.BLOCK_TYPE, "yourmodid");

public static final Supplier<MapCodec<SimpleBlock>> SIMPLE_CODEC = REGISTRAR.register(
    "simple",
    () -> BlockBehaviour.simpleCodec(SimpleBlock::new)
);
```

Если подкласс блока содержит больше параметров, то для создания `MapCodec` следует использовать [`RecordCodecBuilder#mapCodec`](../../datastorage/codecs.md#записи), передав `BlockBehaviour#propertiesCodec` для параметра `BlockBehaviour.Properties`.

```java
// Для некоторого подкласса блока
public class ComplexBlock extends Block {
    public ComplexBlock(int value, BlockBehavior.Properties properties) {
        // ...
    }

    @Override
    public MapCodec<ComplexBlock> codec() {
        return COMPLEX_CODEC.get();
    }

    public int getValue() {
        return this.value;
    }
}

// В некотором классе регистрации
public static final DeferredRegister<MapCodec<? extends Block>> REGISTRAR = DeferredRegister.create(BuiltInRegistries.BLOCK_TYPE, "yourmodid");

public static final Supplier<MapCodec<ComplexBlock>> COMPLEX_CODEC = REGISTRAR.register(
    "simple",
    () -> RecordCodecBuilder.mapCodec(instance ->
        instance.group(
            Codec.INT.fieldOf("value").forGetter(ComplexBlock::getValue),
            BlockBehaviour.propertiesCodec() // представляет параметр BlockBehavior.Properties
        ).apply(instance, ComplexBlock::new)
    )
);
```

> **Примечание:**
> Хотя типы блоков в настоящее время практически не используются, ожидается, что их важность возрастет в будущем, поскольку Mojang продолжает двигаться к структуре, ориентированной на кодеки.

### Вспомогательные методы `DeferredRegister.Blocks`

Мы уже обсуждали, как создать `DeferredRegister.Blocks` [выше](#один-блок-чтобы-править-всеми), а также то, что он возвращает `DeferredBlock`. Теперь давайте посмотрим, какие еще утилиты предлагает специализированный `DeferredRegister`. Начнем с `#registerBlock`:

```java
public static final DeferredRegister.Blocks BLOCKS = DeferredRegister.createBlocks("yourmodid");

public static final DeferredBlock<Block> EXAMPLE_BLOCK = BLOCKS.register(
    "example_block", registryName -> new Block(
        BlockBehaviour.Properties.of()
            // ID должен быть установлен для блока
            .setId(ResourceKey.create(Registries.BLOCK, registryName))
    )
);

// То же, что и выше, за исключением того, что свойства блока создаются сразу.
// setId также вызывается внутренне для объекта свойств.
public static final DeferredBlock<Block> EXAMPLE_BLOCK = BLOCKS.registerBlock(
    "example_block",
    Block::new, // Фабрика, в которую будут переданы свойства.
    BlockBehaviour.Properties.of() // Свойства для использования.
);
```

Если вы хотите использовать `Block::new`, вы можете полностью опустить фабрику:

```java
public static final DeferredBlock<Block> EXAMPLE_BLOCK = BLOCKS.registerSimpleBlock(
    "example_block",
    BlockBehaviour.Properties.of() // Свойства для использования.
);
```

Это делает то же самое, что и предыдущий пример, но немного короче. Конечно, если вы хотите использовать подкласс `Block`, а не сам `Block`, вам придется использовать предыдущий метод.

### Ресурсы

Если вы зарегистрируете свой блок и разместите его в мире, вы обнаружите, что у него отсутствуют такие вещи, как текстура. Это связано с тем, что [текстуры](../../resources/client/textures.md), среди прочего, обрабатываются системой ресурсов Minecraft. Чтобы применить текстуру к блоку, вы должны предоставить [модель](../../resources/client/models/index.md) и [файл состояния блока](../../resources/client/models/blockstates.md), который связывает блок с текстурой и формой. Прочтите связанные статьи для получения дополнительной информации.

## Использование блоков

Блоки очень редко используются напрямую для выполнения действий. Фактически, две, вероятно, самые распространенные операции во всем Minecraft — получение блока в позиции и установка блока в позиции — используют состояния блоков, а не блоки. Общий подход к проектированию заключается в том, что блок определяет поведение, но поведение фактически выполняется через состояния блоков. Из-за этого `BlockState` часто передаются в методы `Block` в качестве параметра. Для получения дополнительной информации о том, как используются состояния блоков и как получить их из блока, см. [Использование состояний блоков](states.md#использование-состояний-блоков).

В некоторых ситуациях несколько методов `Block` используются в разное время. Следующие подразделы перечисляют наиболее распространенные конвейеры (pipelines), связанные с блоками. Если не указано иное, все методы вызываются на обеих логических сторонах и должны возвращать одинаковый результат на обеих сторонах.

### Размещение блока

Логика размещения блока вызывается из `BlockItem#useOn` (или реализации этого метода в каком-либо подклассе, например, в `PlaceOnWaterBlockItem`, который используется для кувшинок). Для получения дополнительной информации о том, как игра доходит до этого, см. [Клик правой кнопкой мыши по предмету](../../items/interactions.md#клик-правой-кнопкой-мыши-по-предмету). На практике это означает, что как только по `BlockItem` щелкают правой кнопкой мыши (например, по предмету булыжника), вызывается это поведение.

*   Проверяются несколько предварительных условий, например, что вы не находитесь в режиме наблюдателя, что все необходимые флаги функций для блока включены или что целевая позиция не находится за пределами границы мира. Если хотя бы одна из этих проверок не пройдена, конвейер завершается.
*   Вызывается `BlockBehaviour#canBeReplaced` для блока, который в данный момент находится в позиции, куда пытаются разместить блок. Если он возвращает `false`, конвейер завершается. Яркие примеры, возвращающие `true` здесь, — высокая трава или слои снега.
*   Вызывается `Block#getStateForPlacement`. Здесь, в зависимости от контекста (который включает информацию, такую как позиция, вращение и сторона, на которую размещается блок), могут быть возвращены разные состояния блока. Это полезно, например, для блоков, которые можно размещать в разных направлениях.
*   Вызывается `BlockBehaviour#canSurvive` с состоянием блока, полученным на предыдущем шаге. Если он возвращает `false`, конвейер завершается.
*   Состояние блока устанавливается в уровень с помощью вызова `Level#setBlock`.
    *   В этом вызове `Level#setBlock` вызывается `BlockBehaviour#onPlace`.
*   Вызывается `Block#setPlacedBy`.

### Разрушение блока

Разрушение блока немного сложнее, так как требует времени. Процесс можно грубо разделить на три этапа: "инициация", "добыча" и "фактическое разрушение".

*   При щелчке левой кнопкой мыши входим в стадию "инициация".
*   Теперь левую кнопку мыши нужно удерживать, входя в стадию "добыча". **Методы этой стадии вызываются каждый тик.**
*   Если стадия "продолжение" не прерывается (отпусканием левой кнопки мыши) и блок разрушается, входим в стадию "фактическое разрушение".

Или для тех, кто предпочитает псевдокод:

```java
левыйКлик();
стадияИнициации();
while (левыйКликУдерживается()) {
    стадияДобычи();
    if (блокРазрушен()) {
        стадияФактическогоРазрушения();
        break;
    }
}

```

Следующие подразделы далее разбивают эти этапы на фактические вызовы методов. Информацию о том, как игра переходит от левого клика к этому конвейеру, см. в разделе [Клик левой кнопкой мыши по предмету](../../items/interactions.md#клик-левой-кнопкой-мыши-по-предмету).

#### Стадия "Инициация"

*   Проверяются несколько предварительных условий, например, что вы не находитесь в режиме наблюдателя, что все необходимые флаги функций для `ItemStack` в вашей основной руке включены или что рассматриваемый блок не находится за пределами границы мира. Если хотя бы одна из этих проверок не пройдена, конвейер завершается.
*   Срабатывает событие `PlayerInteractEvent.LeftClickBlock`. Если событие отменено, конвейер завершается.
    *   Обратите внимание, что при отмене события на клиенте пакеты на сервер не отправляются, и, следовательно, логика на сервере не выполняется.
    *   Однако отмена этого события на сервере все равно приведет к выполнению клиентского кода, что может привести к рассинхронизации!
*   Вызывается `Block#attack`.

#### Стадия "Добыча"

*   Срабатывает событие `PlayerInteractEvent.LeftClickBlock`. Если событие отменено, конвейер переходит к стадии "завершение".
    *   Обратите внимание, что при отмене события на клиенте пакеты на сервер не отправляются, и, следовательно, логика на сервере не выполняется.
    *   Однако отмена этого события на сервере все равно приведет к выполнению клиентского кода, что может привести к рассинхронизации!
*   Вызывается `Block#getDestroyProgress` и добавляется к внутреннему счетчику прогресса разрушения.
    *   `Block#getDestroyProgress` возвращает значение float от 0 до 1, представляющее, на сколько должен увеличиваться счетчик прогресса разрушения каждый тик.
*   Соответствующим образом обновляется наложение прогресса (текстура трещин).
*   Если прогресс разрушения больше 1.0 (т.е. завершен, т.е. блок должен быть разрушен), стадия "добыча" завершается, и начинается стадия "фактическое разрушение".

#### Стадия "Фактическое разрушение"

*   Вызывается `Item#canAttackBlock`. Если он возвращает `false` (определяя, что блок не должен быть разрушен), конвейер переходит к стадии "завершение".
*   Вызывается `Player#canUseGameMasterBlocks`, если блок является экземпляром `GameMasterBlock`. Это определяет, имеет ли игрок возможность разрушать блоки только для творческого режима. Если `false`, конвейер переходит к стадии "завершение".
*   Только на сервере: Вызывается `Player#blockActionRestricted`. Это определяет, может ли текущий игрок разрушать блок. Если `true`, конвейер переходит к стадии "завершение".
*   Только на сервере: Срабатывает событие `BlockEvent.BreakEvent`. Если отменено или `getExpToDrop` возвращает -1, конвейер переходит к стадии "завершение". Начальное состояние отмены определяется тремя вышеуказанными методами.
    *   Только на сервере: Срабатывает событие `PlayerEvent.HarvestCheck`. Если `canHarvest` возвращает `false` или `BlockState`, переданный в событие разрушения, равен null, то начальный опыт для события будет равен 0.
    *   Только на сервере: Вызывается `IBlockExtension#getExpDrop`, если `PlayerEvent.HarvestCheck#canHarvest` возвращает `true`. Это значение передается в `BlockEvent.BreakEvent#getExpToDrop` для последующего использования в конвейере.
*   Только на сервере: Вызывается `IBlockExtension#canHarvestBlock`. Это определяет, можно ли собрать блок, т.е. разрушить с выпадением предметов.
*   Вызывается `IBlockExtension#onDestroyedByPlayer`. Если он возвращает `false`, конвейер переходит к стадии "завершение". В этом вызове `IBlockExtension#onDestroyedByPlayer`:
    *   Вызывается `Block#playerWillDestroy`.
    *   Состояние блока удаляется из уровня с помощью вызова `Level#setBlock` с `Blocks.AIR.defaultBlockState()` в качестве параметра состояния блока.
        *   В этом вызове `Level#setBlock` вызывается `Block#onRemove`.
*   Вызывается `Block#destroy`.
*   Только на сервере: Если предыдущий вызов `IBlockExtension#canHarvestBlock` вернул `true`, вызывается `Block#playerDestroy`.
    *   Только на сервере: Вызывается `Block#dropResources`. Это определяет, что выпадает из блока при добыче.
        *   Только на сервере: Срабатывает событие `BlockDropsEvent`. Если событие отменено, то при разрушении блока ничего не выпадает. В противном случае каждый `ItemEntity` в `BlockDropsEvent#getDrops` добавляется в текущий уровень.
*   Только на сервере: Вызывается `Block#popExperience` с результатом предыдущего вызова `IBlockExtension#getExpDrop`, если этот вызов вернул значение больше 0.

#### Скорость добычи

Скорость добычи рассчитывается на основе твердости блока, скорости используемого [инструмента](../../items/tools.md) и нескольких [атрибутов](../../entities/attributes.md) сущности в соответствии со следующими правилами:

```java
// Это вернет скорость добычи инструмента, или 1, если удерживаемый предмет пуст, не является инструментом,
// или не применим для разрушаемого блока.
float destroySpeed = item.getDestroySpeed(blockState);
// Если у нас есть подходящий инструмент, добавьте атрибут minecraft:mining_efficiency как аддитивный модификатор.
if (destroySpeed > 1) {
    destroySpeed += player.getAttributeValue(Attributes.MINING_EFFICIENCY);
}
// Применить эффекты от спешки или силы проводника.
if (player.hasEffect(MobEffects.DIG_SPEED) || player.hasEffect(MobEffects.CONDUIT_POWER)) {
    int haste = player.hasEffect(MobEffects.DIG_SPEED)
        ? player.getEffect(MobEffects.DIG_SPEED).getAmplifier()
        : 0;
    int conduitPower = player.hasEffect(MobEffects.CONDUIT_POWER)
        ? player.getEffect(MobEffects.CONDUIT_POWER).getAmplifier()
        : 0;
    int amplifier = Math.max(haste, conduitPower);
    destroySpeed *= 1 + (amplifier + 1) * 0.2f;
}
// Применить эффект медлительности.
if (player.hasEffect(MobEffects.DIG_SLOWDOWN)) {
    destroySpeed *= switch (player.getEffect(MobEffects.DIG_SLOWDOWN).getAmplifier()) {
        case 0 -> 0.3F;
        case 1 -> 0.09F;
        case 2 -> 0.0027F;
        default -> 8.1E-4F;
    };
}
// Добавить атрибут minecraft:block_break_speed как мультипликативный модификатор.
destroySpeed *= player.getAttributeValue(Attributes.BLOCK_BREAK_SPEED);
// Если игрок находится под водой, применить штраф к скорости добычи под водой мультипликативно.
if (player.isEyeInFluid(FluidTags.WATER)) {
    destroySpeed *= player.getAttributeValue(Attributes.SUBMERGED_MINING_SPEED);
}
// Если игрок пытается сломать блок в воздухе, сделать добычу в 5 раз медленнее.
if (!player.onGround()) {
    destroySpeed /= 5;
}
destroySpeed = /* Здесь срабатывает событие PlayerEvent.BreakSpeed, позволяя моддерам дополнительно изменять это значение. */;
return destroySpeed;

```

Точный код для этого можно найти в `Player#getDestroySpeed` для справки.

### Тики (Ticking)

Тики — это механизм, который обновляет (выполняет тик) части игры каждые 1/20 секунды, или 50 миллисекунд ("один тик"). Блоки предоставляют различные методы тиков, которые вызываются по-разному.

#### Серверные тики и планирование тиков

`BlockBehaviour#tick` вызывается в двух случаях: либо через стандартные [случайные тики](#случайные-тики) (см. ниже), либо через запланированные тики. Запланированные тики можно создать с помощью `Level#scheduleTick(BlockPos, Block, int)`, где `int` обозначает задержку. Это используется в различных местах ванильного Minecraft, например, механизм наклона больших капельников сильно зависит от этой системы. Другие известные пользователи — различные компоненты красного камня.

#### Клиентские тики

`Block#animateTick` вызывается исключительно на клиенте, каждый кадр. Здесь происходит поведение только для клиента, например, появление частиц факела.

#### Погодные тики

Погодные тики обрабатываются `Block#handlePrecipitation` и выполняются независимо от обычных тиков. Они вызываются только на сервере, только когда идет дождь в какой-либо форме, с вероятностью 1 к 16. Это используется, например, котлами, которые наполняются во время дождя или снегопада.

#### Случайные тики

Система случайных тиков работает независимо от обычных тиков. Случайные тики должны быть включены через `BlockBehaviour.Properties` блока путем вызова метода `BlockBehaviour.Properties#randomTicks()`. Это позволяет блоку участвовать в механике случайных тиков.

Случайные тики происходят каждый тик для определенного количества блоков в чанке. Это количество определяется правилом игры `randomTickSpeed`. При значении по умолчанию 3, каждый тик выбираются 3 случайных блока из чанка. Если у этих блоков включены случайные тики, то вызываются их соответствующие методы `BlockBehaviour#randomTick`.

Случайные тики используются широким спектром механик в Minecraft, таких как рост растений, таяние льда и снега или окисление меди.
---
<div align="center"><table border="1"><tr><td align="center">Предыдущий раздел<br><a href="./Concepts/Events.md">События</a></td><td align="center">Следующий раздел<br><a href="states.md">Состояния блоков</a></td></tr></table></div>

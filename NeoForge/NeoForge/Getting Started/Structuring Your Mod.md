# Структурирование вашего мода

Структурированные моды удобны для сопровождения, внесения вклада и более четкого понимания основной кодовой базы. Ниже перечислены некоторые рекомендации по Java, Minecraft и NeoForge.

> **Примечание:**
> Вы не обязаны следовать приведенным ниже советам; вы можете структурировать свой мод так, как считаете нужным. Однако настоятельно рекомендуется это делать.

<a id="packaging"></a>
## Организация пакетов

При структурировании вашего мода выберите уникальную структуру пакетов верхнего уровня. Многие программисты используют одинаковые имена для разных классов, интерфейсов и т. д. Java позволяет классам иметь одинаковые имена, если они находятся в разных пакетах. Таким образом, если два класса имеют один и тот же пакет с одинаковым именем, будет загружен только один, что, скорее всего, приведет к сбою игры.

```text
a.jar
    - com.example.ExampleClass
b.jar
    - com.example.ExampleClass // Этот класс обычно не будет загружен
```

Это становится еще более актуальным при загрузке модулей. Если в двух пакетах с одинаковым именем в отдельных модулях есть файлы классов, это приведет к сбою загрузчика модов при запуске, поскольку модули модов экспортируются в игру и другие моды.

```text
модуль A
    - пакет X
        - класс I
        - класс J
модуль B
    - пакет X // Этот пакет вызовет сбой загрузчика модов, так как уже существует экспортируемый модуль с пакетом X
        - класс R
        - класс S
        - класс T
```

Таким образом, ваш пакет верхнего уровня должен быть чем-то, чем вы владеете: доменом, адресом электронной почты, (поддоменом) веб-сайта и т. д. Это может быть даже ваше имя или имя пользователя, если вы можете гарантировать, что оно будет однозначно идентифицируемым в пределах ожидаемой цели. Кроме того, пакет верхнего уровня должен также соответствовать вашему [ID группы](./Mod%20Files.md#the-group-id).

| Тип       | Значение            | Пакет верхнего уровня |
| :-------: | :-----------------: | :-------------------- |
| Домен     | `example.com`       | `com.example`         |
| Поддомен  | `example.github.io` | `io.github.example`   |
| Email     | `example@gmail.com` | `com.gmail.example`   |

Следующий уровень пакета должен содержать идентификатор вашего мода (например, `com.example.examplemod`, где `examplemod` — это id мода). Это гарантирует, что, если у вас нет двух модов с одинаковым id (чего никогда не должно быть), ваши пакеты не должны иметь проблем с загрузкой.

Вы можете найти дополнительные соглашения об именовании на [странице руководства Oracle](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).

### Организация подпакетов

В дополнение к пакету верхнего уровня настоятельно рекомендуется разделять классы вашего мода между подпакетами. Существует два основных метода, как это сделать:

*   **Группировка по функциям**: Создавайте подпакеты для классов с общей целью. Например, блоки могут находиться в `block`, предметы в `item`, сущности в `entity` и т. д. Сам Minecraft использует похожую структуру (с некоторыми исключениями).
*   **Группировка по логике**: Создавайте подпакеты для классов с общей логикой. Например, если вы создаете новый тип верстака, вы поместите его блок, меню, предмет и многое другое в `feature.crafting_table`.

#### Пакеты для клиента, сервера и данных

В общем, код, предназначенный только для определенной стороны или среды выполнения, должен быть изолирован от других классов в отдельном подпакете. Например, код, связанный с [генерацией данных](../resources/data-generation.md), должен находиться в пакете `data`, а код, выполняемый только на выделенном сервере, — в пакете `server`.

Настоятельно рекомендуется изолировать [код только для клиента](../Concepts/Sides.md) в подпакете `client`. Это связано с тем, что выделенные серверы не имеют доступа ни к одному из пакетов только для клиента в Minecraft и вызовут сбой, если ваш мод попытается получить к ним доступ. Таким образом, наличие выделенного пакета обеспечивает разумную проверку того, что вы не обращаетесь к классам другой стороны внутри вашего мода.

## Схемы именования классов

Общая схема именования классов упрощает расшифровку назначения класса или легкий поиск конкретных классов.

К именам классов обычно добавляется суффикс, указывающий на их тип, например:

*   `Item` с именем `PowerRing` -> `PowerRingItem`.
*   `Block` с именем `NotDirt` -> `NotDirtBlock`.
*   Меню для `Oven` -> `OvenMenu`.

> **Совет:**
> Mojang обычно следует схожей структуре для всех классов, кроме сущностей (entities). Они представлены просто своими именами (например, `Pig`, `Zombie` и т. д.).

## Выбирайте один метод из множества

Существует множество методов для выполнения определенной задачи: регистрация объекта, прослушивание событий и т. д. Обычно рекомендуется быть последовательным, используя один метод для выполнения данной задачи. Это улучшает читаемость и позволяет избежать странных взаимодействий или избыточности, которые могут возникнуть (например, ваш обработчик событий запускается дважды).

---
<div align="center"><table><tr><td align="center">Предыдущий раздел<br><a href="Mod%20Files.md">Файлы мода</a></td><td align="center">Следующий раздел<br><a href="Versioning.md">Версионирование</a></td></tr></table></div>
